## Education - Bachelors of Engineering (Majors in Computer Science) 

_My studies at the university_ —
* Majors from computer science
  * Foundations for Data Analytics
  * Problem Solving using Java
  * Software Engineering
  * Object Oriented Programming
  * Operating Systems
  * Internet of Things
  * Data Structures
  * Database Management Systems
  * Cyber Security & Digital Forensics
  * Design & Analysis of Algorithms
  * Data Warehousing & Data Mining
  * Data Visualization
  * Computer Networks
  * Artificial Intelligence
  * C Programming
* Minor courses in English language
  * English for Essential Communication
  * English for Effective Communication
  * Climate Fiction & Narratives to Save the World
* Minor courses in electronics engineering
  * Fundamentals of Electrical & Electronics Engineering
  * Digital Logic Design
  * Sensors & Control Systems
  * Computer Organization & Architecture
  * Microcontrollers & Interfacing
  * Automotive Electronics
* Minor course in foreign language
  * Spanish Language
* Minor courses in management & humanities
  * Ethics & Values
  * Lean Startup Management
  * Cost & Management Accounting
* Minor courses in physics 
  * Modern Physics
  * Optoelectronics
  * Nanotechnology
  * Solar Photovoltaics
* Minor courses in mechanical engineering
  * Engineering Mechanics
  * Engineering Drawing
  * Fundamentals of Robotics
  * Robot Kinematics & Dynamics
* Minor courses in soft skills
  * Aptitude
  * Arithmetic Problem Solving
  * Skill Enhancement
  * Enhancing Problem Solving Skills
  * Competitive Coding I
  * Competitive Coding II
* Minor courses in chemistry
  * Environmental Studies
  * Engineering Chemistry
  * Energy Materials & Applications
  * Industrial Chemistry
  * Corrosion Science & Engineering
  * Organic Electronics
* Minor courses in mathematics
  * Calculus for Engineers
  * Applications of Differential & Difference Equations
  * Applied Statistics
  * Linear Algebra
  * Discrete Mathematical Structures
  * Optimization Techniques
* Value Added Courses
  * Advanced Data Analytics Tools
  * Data Science & Advanced Analytics
  * Environmental Chemistry & Pollution Control
* Team projects
  * Engineering Clinics I
  * Engineering Clinics II
  * Capstone Project
* Major individual project
  * Senior Design Project

| Course Code | Course Title |
|-------------|--------------|
| CSE1006     | Foundations for Data Analytics |
| CSE1004     | Problem Solving using Java |
| CSE1005     | Software Engineering |
| CSE2005     | Object Oriented Programming |
| CSE2008     | Operating Systems |
| CSE4011     | Internet of Things |
| CSE2001     | Data Structures |
| CSE2007     | Database Management Systems |
| CSE2011     | Cyber Security & Digital Forensics |
| CSE3004     | Design & Analysis of Algorithms |
| CSE4005     | Data Warehousing & Data Mining |
| CSE3006     | Data Visualization |
| CSE3003     | Computer Networks |
| CSE3002     | Artificial Intelligence |
| ONL1001     | C Programming |
| ENG1001     | English for Essential Communication |
| ENG1002     | English for Effective Communication |
| ENG1016     | Climate Fiction & Narratives to Save the World |
| ECE1002     | Fundamentals of Electrical & Electronics Engineering |
| ECE1003     | Digital Logic Design |
| ECE1008     | Sensors & Control Systems |
| ECE2002     | Computer Organization & Architecture |
| ECE2004     | Microcontrollers & Interfacing |
| ECE4004     | Automotive Electronics |
| FRL1004     | Spanish Language |
| MGT1001     | Ethics & Values |
| MGT1002     | Lean Startup Management |
| HUM2003     | Cost & Management Accounting |
| PHY1009     | Engineering Mechanics |
| PHY1008     | Modern Physics |
| PHY2004     | Optoelectronics |
| PHY2005     | Nanotechnology |
| PHY2006     | Solar Photovoltaics |
| MEC1004     | Engineering Drawing |
| MEC1006     | Introduction to Robotics |
| MEC2016     | Robot Kinematics & Dynamics |
| STS1002     | Aptitude |
| STS1007     | Arithmetic Problem Solving |
| STS2006     | Skill Enhancement |
| STS2007     | Enhancing Problem Solving Skills |
| STS3006     | Competitive Coding I |
| STS4005     | Competitive Coding II |
| CHY1001     | Environmental Studies |
| CHY1004     | Engineering Chemistry |
| CHY1007     | Energy Materials & Applications |
| CHY1005     | Industrial Chemistry |
| CHY1006     | Corrosion Science & Engineering |
| CHY2002     | Organic Electronics |
| MAT1001     | Calculus for Engineers |
| MAT1002     | Applications of Differential & Difference Equations |
| MAT1011     | Applied Statistics |
| MAT2005     | Linear Algebra |
| MAT1003     | Discrete Mathematical Structures |
| MAT2003     | Optimization Techniques |
| Value Added Course | Advanced Data Analytics Tools|
| Value Added Course | Data Science & Advanced Analytics| 
| Value Added Course | Environmental Chemistry & Pollution Control|
| ECS1001     | Engineering Clinics I |
| ECS1002     | Engineering Clinics II |
| CAP4001     | Capstone Project |
| BIC4002     | Senior Design Project |

---


## Skills
* C Programming
* R Programming
* Java Programming
* Android App Development
* Desktop App Development
* C++ Programming
* MATLAB
* Verilog HDL
* Robotic Design
* Arduino Programming
* Python Programming
* Assembly Language
* XML 
* Object Oriented Programming
* Hardware & Software Architecture
* JavaFX & Java Swing
* SQL
* NI Multisim
* NI LabVIEW
* Football ⚽

---

## Projects
### Android QR Code Generator
* This is an user-friendly Android app that creates QR code based on texts, URLs or any paragraphs typed by user. QR code can be saved and shared as PNG file.
### Android QR Code and Barcode Reader App
* Android app which utilizes ZXing library & scans and reads barcodes and QR codes and saves the obtained outputs in a list which can be deleted further.
### Android To-Do App
* An Android app that helps user to note down, edit & save tasks. Similar to To-Do application I developed for desktop PCs.
### Desktop PDF Modification Tool
* Desktop app that modifies PDF by rotating, adding, deleting pages of PDF document.
### IoT-based Mini Weather Station
* This is a mini weather monitoring system built using internet of things (IoT), Arduino UNO and involves a variety of sensors.
* The system acquires weather data in the vicinity using the sensors and uses internet for sharing the data so the weather monitoring tasks can be performed.
* ESP8266 Wi-Fi module enables internet connectivity using TCP communication protocol and the weather conditions i.e. temperature, humidity, air quality and atmospheric pressure are displayed while the weather report will be displayed on LCD screen used in the system.
* The system utilizes DHT11 sensor (for temperature & humidity), BMP180 sensor (for atmospheric pressure) and MQ135 sensor (for air quality).
* I built this project to serve the purpose of project component of the course Internet of Things in my 3rd academic year.
### Desktop Code Parser & UML Maker for Java Codes
* A desktop application that parses Java code entered by user and generates UML diagrams.
### Desktop To-Do App
* This is a task management application for desktop PCs. It allows user to note all tasks save them in a file and user can also open pre-existing files from PC.
### Desktop Image Cropping Software
* Desktop application that crops image as per the dimensions entered by user.
### Desktop PDF Merger Tool
* Created a tool to merge multiple PDFs into a single file on desktop.
### Desktop Python Code Editor
* A lightweight desktop app for Python programming.
### Hospital Management Software
* This software assists in managing medical conditions & records of patient, details of doctor/staff, services offered by the clinic, and booking & availability of rooms.
* The software uses SQL database for storage of doctor/staff user credentials and all sort of details.
* I built this project for Software Engineering course in my 3rd academic year.
### Fourier Transform Visualizer
* A Python application for visualizing Fourier Transforms.
### Contour Plotter Application
* This is a desktop application that allows users to generate 3D contour plots based on mathematical expressions and visualize them in a separate window.
* Additionally, it provides functionality to save the generated plots as either PNG or can print it to PDF file.
* This app utilize external libraries for computations and processing of contour plots.
### 3D Graphing Software
* This desktop application visualizes mathematical functions through 3D mesh-like graphs.
* Use shall write the mathematical functions.
### Desktop Spreadsheet Software
* Desktop software in which user can create, edit, save and export spreadsheets and workbooks.
### Integral Visualization Software
* Desktop software in which user can provide data values to compute & analyze several integral approximations via dynamic simulation of the plots.
### Command Prompt Emulator
* Desktop app that replicates the actual Command Prompt (cmd.exe) and performs all the functions. 
### Desktop Graphing Tool
* This is a desktop application that enables user to visualize mathematical functions via 2D plots.
* User shall write the mathematical functions, variables and data values.
### Polynomial Evaluation Software
* This desktop software offers user the facility to perform different operation on polynomial functions i.e. addition, subtraction, multiplication, division, integral & differential calculus, and visualization.
* It is required to write the commands and polynomial expressions correctly for a specific task that is to be performed.
* The software includes a detailed documentation that acts as user guide about how to use the software.
### Liquid Level Monitoring System using NI LabVIEW
* Liquid level monitoring system using NI LabVIEW.
### Text to Speech Converter using NI LabVIEW
* This LabVIEW-based application reads out the text files using constructor node and invoke node.
* The text to speech conversion is carried out using speech synthesizer and a component called Speak.
* The components for performing the tasks are provided by .NET framework.
### CPU Scheduler for Desktop
* A desktop tool that demonstrates CPU Scheduling and involves six major scheduling algorithms.
### Data Structures Visualization App
* A simple desktop app by which user can design some common data structures by entering the required values.
* This app is quite simple and doesn't have much functionalities. 
### Desktop Paint App
* Paint application for desktop PCs
### Simulation of Antikythera Mechanism
* This application is developed to simulate the functionality and features of the historic Antikythera Mechanism, an ancient Greek analog computer.
* Built with JavaFX, the simulation replicates the movements, calculations, and functionalities of Antikythera Mechanism, offering a modern interpretation.
* [Click here](https://github.com/KMORaza/Antikythera_Mechanism_Simulation)
### Analysis of Modern Periodic Table using Machine Learning
* Analysis of Modern Periodic Table using some Machine Learning techniques
* [Click here to view repository](https://github.com/KMORaza/Periodic_Table_Analysis) and [Click here to view notebook](https://github.com/KMORaza/Periodic_Table_Analysis/blob/main/Periodic_Table_Analysis.ipynb) 
### Engineering Clinics I: Arduino based Smart Lock System
* Our group built this smart lock system using Arduino UNO and RFID-RC522 Module.
* This project automates manual locking system and makes it more secured. Moreover, it is economically inexpensive as well as user-friendly.
* I'm really thankful to my entire team for all the tasks including design, assembly, programming, fixing errors, and documentation.
* We built this project for our first engineering clinics in university.
### Engineering Clinics II: Smart Irrigation System using NodeMCU, IoT and Android
* The system aims to implement smart and efficient irrigation/gardening practices via internet of things, cloud technology, a variety of sensors along with an Android app for better monitoring.
* We used NodeMCU for transferring data through Wi-Fi and Firebase is used for storage. Android app is used for monitoring and analyzing data.
* Moreover minimization of water wastage and enhancing the utilization further becomes another advantage that must be considered since traditional irrigation techniques wastes a lot of water.
* The sensors we used are DHT11 (for temperature/humidity) and soil moisture sensor.
* I'm really thankful to my entire team members for all the tasks including design, assembly, programming, fixing errors, and documentation.
* We built this project for our second engineering clinics in university.
### Senior Design Project: Surface Damage Detection and Analysis using Machine Learning
* Road Crack & Pothole Detection — Bringing this to a desktop application empowers stakeholders at various levels, from local authorities to transportation agencies leading to more comprehensive road maintenance strategies and safer driving conditions. 
* Concrete Crack Classification — By automating the identification of concrete cracks, the solution aids in the early detection of structural weaknesses in buildings and bridges. This proactive approach can prevent potential disasters, ensuring the safety of inhabitants and preserving infrastructure integrity.
* Concrete Crack Segmentation & Detection — Going beyond classification, segmenting and detecting concrete cracks enables precise localization of damage. This targeted approach facilitates efficient repair and maintenance, extending the lifespan of structures and minimizing costly repairs.
* Metal Defect Detection — In industrial settings, the detection of metal defects is essential for maintaining product quality and safety standards. The solution streamlines this process, ensuring that faulty components are identified early, enhancing manufacturing efficiency, and minimizing the risk of product failures.
* Steel Damage Detection — The early detection of steel damage is critical in industries ranging from construction to aerospace. The solution provides a reliable method for identifying defects in steel structures, ensuring compliance with stringent safety regulations and enhancing structural reliability.
* Car Damage Detection — Vehicle safety is paramount for both drivers and pedestrians. By automating the detection of car damage, your project contributes to the timely assessment of vehicle integrity, facilitating necessary repairs and ultimately enhancing road safety.
* Ice Fracture Detection & Analysis — In regions prone to icy conditions, the detection and analysis of ice fractures are instrumental in predicting and mitigating potential hazards. The solution enables proactive measures to safeguard communities and infrastructure during cold weather events.
* _`I built this entire project in my final academic year to fulfill the needs of Senior Design Project course which was strictly required to be done individually.`_
### Data Visualization Tool
* [Click here](https://001-simple-data-visualization-tool.netlify.app/)
### To-Do List Web App
* [Click here](https://002-todo-list-web-app.netlify.app/)
### Scientific Calculator Web App
* [Click here](https://003-scientific-calculator-web-app.netlify.app/)
### RGB Color Picker
* [Click here](https://007-rbg-color-picker.netlify.app/)
### Trigonometry Calculator
* [Click here](https://008-trigonometry-calculator.netlify.app/)
### Pokédex Web App
* [Click here](https://012-pokedex-version3.netlify.app/) 
### BMI Calculator
* [Click here](https://013-bmi-calculator.netlify.app/)
### Home Loan Calculator
* [Click here](https://014-home-loan-calculator.netlify.app/)
### QR Code Creator Web App
* [Click here](https://015-qrcode-creator.netlify.app/)
### Text Editor Web App
* [Click here](https://017-text-editor.netlify.app/)
### Barcode & QR Code Reader Web App
* [Click here](https://016-barcode-and-qrcode-reader.netlify.app/)
### Memo Web Application
* [Click here](https://018-memo-app.netlify.app/)
### Periodic Table App
* [Click here](https://019-periodic-table.netlify.app/) 
### Visualization of Harmonic Oscillator
* [Click here](https://020-harmonic-oscillator-visualization.netlify.app/) 
### Simulation of Potts Model
* [Click here](https://009-potts-model-simulation.netlify.app/) 
### Simulation of Heisenberg Model
* [Click here](https://022-heisenberg-model-simulation.netlify.app/) 
### Physical Characteristics of Saturn Modelled/Simulated in OpenSCAD
*  Model/Simulation of system of moons and rings of Saturn
*  Significant families of moons of Saturn included are Major moons, Gallic moons and Norse moons.
*  The major rings i.e. D-Ring, C-Ring, B-Ring, A-Ring, F-Ring are present along with Cassini-Region, Roche-Region, structures within Cassini-Region, etc.
*  Written entirely in OpenSCAD.
*  _Check_ [_repository_](https://github.com/KMORaza/Moons_And_Rings_Of_Saturn) _and_ [_CAD scripts_](https://github.com/KMORaza/Moons_And_Rings_Of_Saturn/tree/main/Moons%20%26%20Rings%20of%20Saturn/CAD%20scripts) 
### Ant Colony Optimization & Applications
* Variants of Ant Colony Optimization
    * Basic Implementation of Ant Colony Optimization
    * Ant Colony Optimization with a bias towards exploitation
    * Ant Colony Optimization with a local pheromone updating rule
    * Elitist Ant System
    * Max-Min Ant System
    * Rank-based ant system
    * Parallel Ant Colony Optimization
    * Continuous Orthogonal Ant Colony
    * Recursive Ant Colony Optimization
* Applications in Scheduling
    * Sequential Ordering Problem
    * Job-Shop Scheduling Problem
    * Open-Shop Scheduling Problem
    * Permutation Flow Shop Problem
    * Single Machine Total Tardiness Problem
    * Single Machine Total Weighted Tardiness Problem
    * Resource-Constrained Project Scheduling Problem
    * Group-Shop Scheduling Problem
    * Single-Machine Total Tardiness Problem with Sequence Dependent Setup Times
    * Multistage Flowshop Scheduling Problem
    * Assembly Sequence Planning
* Applications in Vehicle Routing
    * Capacitated Vehicle Routing Problem
    * Multi-Depot Vehicle Routing Problem
    * Period Vehicle Routing Problem
    * Split Delivery Vehicle Routing Problem
    * Stochastic Vehicle Routing Problem
    * Vehicle Routing Problem with Pick-Up and Delivery
    * Vehicle Routing Problem with Time Windows
    * Time Dependent Vehicle Routing Problem with Time Windows
    * Vehicle Routing Problem with Time Windows and Multiple Service Workers
* Applications in Assignment
    * Quadratic Assignment Problem
    * Generalized Assignment Problem
    * Frequency Assignment Problem
       * Redundancy Allocation Problem
* Applications in Sets
    * Set Cover Problem
    * Partition Problem
    * Weight Constrained Graph Tree Partition Problem
    * Arc-Weighted l-Cardinality Tree Problem
    * Multiple Knapsack Problem
    * Maximum Independent Set Problem
* Applications in Electronics
    * Antenna Optimization
    * CMOS Amplifier Optimization
    * Reversible Circuit Synthesis
* [Python notebooks can viewed here](https://github.com/KMORaza/Py-ACO?tab=readme-ov-file) and [here is another repository](https://github.com/KMORaza/Ant_Colony_Optimization)
### Implementation of major Advanced Data Structures using Python
* I have written 74 advanced data structures. 
* [Here is repository of C++ programs](https://github.com/KMORaza/Advanced_Data_Structures) and [this one is Python notebook](https://github.com/KMORaza/Advanced_Data_Structures_using_Python/blob/main/Advanced_Data_Structures.ipynb) 
### ACO-based Optimal Urban Drainage Network (first approach)
* Hydraulic Modeling :—
  * The `DesignRainfall` class uses an intensity-duration curve to interpolate rainfall intensity for a given duration, enabling runoff calculations.
  * `CatchmentArea` calculates runoff coefficients based on land use and estimates time of concentration using an empirical formula.
  * `DrainageSolution` computes total runoff volume using rainfall intensity, catchment area, and runoff coefficients.
* Pipe Sizing :—
  * The `calculateRequiredDiameter` method in `Main` uses Manning’s equation to size pipes based on peak flow, slope, and material properties, ensuring capacity meets demand while respecting velocity constraints.
* Detention Facilities :—
  * `DetentionFacility` models detention/retention basins with capacity, release rate, and cost calculations.
  * The `evaluateDetentionRequirements` method selects a facility based on cost per volume, ensuring sufficient storage for 20% of runoff volume.
* Cost Estimation :—
  * Pipes: `DrainagePipe.calculateInstallationCost` accounts for material costs (from `PipeMaterial`) and excavation costs based on pipe diameter and depth.
  * Detention Facilities: `DetentionFacility.getCost` uses a base cost plus a capacity-dependent term, with different rates for detention vs. retention facilities.
  * Total Cost: `DrainageSolution` tracks the total cost by summing pipe and facility costs.
* Regulatory and Environmental Compliance :—
  * `RegulatoryStandards` defines constraints like maximum velocity, minimum slope, and minimum cover.
  * `WaterQualityRequirements` specifies limits for pollutants (TSS, oil/grease) and pH, with a sedimentation requirement.
  * The `calculateWaterQualityScore` method in `DrainageSolution` assigns scores based on HDPE pipe usage and detention facilities, though its simplistic approach (e.g., fixed increments) could be refined.
* Optimization using ant colony optimization (ACO) :—
  * Uses ants to construct solutions by selecting paths from catchment nodes to the outfall.
  * Pheromones guide path selection, updated based on solution quality (inversely proportional to cost).
  * Heuristic information combines factors like pipe length, elevation difference, drainage area, flood risk, and water quality.
  * Builds paths from catchment nodes to the outfall (node 0) using probabilistic node selection.
  * Paths are converted to pipes with calculated diameters.
  * Deposits pheromones based on solution quality and reduces pheromone levels to prevent premature convergence.
  * The implementation includes core ACO elements: pheromone trails, heuristic information, evaporation, and probabilistic path selection.
  * Parameters (`ALPHA`, `BETA`, `Q`, `EVAPORATION_RATE`) are configurable, allowing tuning of exploration vs. exploitation.
  * The heuristic combines multiple factors (distance, elevation, drainage area, water quality), making path selection context-aware.
  * Elevation factor penalizes pipes with insufficient slope, ensuring hydraulic feasibility.
  * Provides detailed metrics (cost, runoff volume, pipe utilization, water quality score), enabling comparison of solutions.
* [Repository](https://github.com/KMORaza/Urban_Drainage_Network_Optimization-ACO-Approach-1)
### ACO-based Optimal Urban Drainage Network (second approach)
* Hydraulic Modeling :—
  * `Rainfall` models rainfall with intensity (mm/hr), duration (hr), and return period (years). It calculates total runoff volume as `intensity * area * duration / 1000`.
  * `DrainageNetwork` estimates required detention volume as 30% of total runoff, using an average runoff coefficient from nodes (defaulting to 0.5 if no nodes exist).
  * `DrainagePipe` uses Manning’s equation to calculate flow capacity based on diameter, slope, and a fixed Manning’s coefficient (0.013, typical for concrete).
  * Slope is derived from the elevation difference between start and end nodes divided by pipe length (calculated as Euclidean distance).
* Cost Estimation :—
  * Pipes: `DrainagePipe.getTotalCost` calculates cost as `length * costPerMeter`, where `costPerMeter` is a constructor parameter (e.g., 100 or 120 in `Main`).
  * Network: `DrainageNetwork.getTotalCost` sums the costs of all pipes.
* Regulatory and Environmental Compliance :—
  * `DrainageNetwork` defines a `maxAllowableFlow` (e.g., 5.0 m³/s), enforced via a penalty in `AntColonyOptimization.calculateSolutionCost` (adds 1,000,000 if flow exceeds this limit).
* Optimization using ACO :—
  * Each ant constructs a solution by iteratively selecting pipes based on pheromone levels and heuristic values (inverse of pipe cost).
  * Pheromones are updated based on solution quality (`pheromoneDeposit / cost`) and evaporated to prevent premature convergence.
  * Builds a solution by selecting all available pipes in a sequence, using `chooseNextPipe` to pick pipes probabilistically.
  * The heuristic is `1 / pipe.getTotalCost`, favoring cheaper pipes.
  * Sums pipe costs and applies a penalty if the minimum pipe flow capacity exceeds `maxAllowableFlow`.
  * The best solution (lowest cost) is stored and applied to the network after optimization.
  * Evaporation and deposition are standard, with configurable parameters (`alpha`, `beta`, `evaporationRate`, `pheromoneDeposit`).
  * The best solution and cost are maintained, ensuring the final network reflects the optimal configuration.
* [Repository](https://github.com/KMORaza/Urban_Drainage_Network_Optimization-ACO-Approach-2)
### ACO-based Groundwater Monitoring Solution
* Solution for groundwater monitoring using ant colony optimization. 
* Check [repository](https://github.com/KMORaza/Groundwater_Monitoring-ACO)
### ACO-based Hydraulic Parameter Estimation
* Hydraulic parameter estimation using ant colony optimization. 
* Check [repository](https://github.com/KMORaza/Hydraulic_Parameter_Estimation-ACO) 
### ACO-based Sediment Management
* Optimizing sediment management in reservoirs using ant colony optimization
* Check [repository](https://github.com/KMORaza/Sediment-Management-ACO)
### BO-based Optimal Urban Drainage Network
* Using Bayesian optimization to design an optimal urban drainage network
* Check [repository](https://github.com/KMORaza/Optimized_Urban_Drainage_Network_Design--Bayesian_Optimization)
### Electric field calculator (console application)
* An electric field calculator written fully in C language
* [Check repository](https://github.com/KMORaza/Electric_Field_Calculator)
### Spiral Generation Simulator
* Desktop app for simulating generation of several mathematical spirals, written fully in C-language, and utilizes GTK4 and Cairo.
* Check [repository](https://github.com/KMORaza/Spiral_Generation_Simulator) 
### Inverter Drive Simulator
* This is a desktop app, written to simulate a variable frequency drive (VFD) controlling an induction motor.
* It provides a user interface for configuring motor and drive parameters, simulating input signals, monitoring motor behavior, injecting faults, and visualizing real-time plots.
* The components of UI are status label, motor parameters, drive settings, input signals, control panel, fault inputs, output labels, plot area.
* The simulation runs in a timed loop (50 ms interval) triggered by the "Run" button.
* Input Collection
* Reads motor parameters, drive settings, speed reference, and fault checkboxes from GUI widgets.
* Parameters: Rated voltage (1–10,000 V), current (1–1,000 A), frequency (1–1,000 Hz), RPM (1–10,000), ramp up/down (0–60 s), max/min frequency (0–1,000 Hz, min ≤ max).
* Speed reference: Slider value (0–100%) scales to max frequency.
* Input Validation
  * Checks for valid ranges. 
  * Displays error messages in the error label (e.g., "Invalid Rated Voltage (1–10000 V)") and stops simulation if invalid.
* Motor and Inverter Update
* Updates motor parameters & drive settings. 
* Sets inverter parameters with rated voltage, target frequency (from speed reference), and fixed modulation index (0.8).
* Updates motor state with target frequency, direction, and ramp times.
* Fault Handling
    * Overcurrent: Triggered if current > 20 A
    * Undervoltage: Triggered if voltage < 300 V
    * Overtemperature: Triggered if temp > 80°C
* Input Signals
    * Speed reference slider scales target frequency.
    * Forward/Reverse buttons toggle motor direction.
    * Run/Stop/Reset buttons control simulation state and fault clearing.
* Motor Behavior
    * V/f control: Voltage and frequency are proportional (V/f = constant).
    * Ramps speed based on user-defined ramp times.
    * Simulates constant torque load (simplified).
* Graphical Monitoring
    * Displays show voltage, current, frequency, torque, and speed.
    * Placeholder: All plots use the PWM voltage waveform scaled to max values (e.g., 1.1 * V_dc for voltage).
* Control Panel
    * Replicates a VFD panel with Run, Stop, Reset, Forward/Reverse buttons.
    * Keypad entry simulates parameter editing (limited to voltage).
* Check [repository](https://github.com/KMORaza/Inverter_Drive_Simulator)  
### Valence Shell Structures Simulator
* Desktop app which simulates structures of valence shells of all the 118 elements of periodic table and is written in C# programming language  .
### Desktop Photo Viewer App
* A photo viewer app written in Java Swing
* [Check repository](https://github.com/KMORaza/Desktop_Photo_Viewer_App)
### Terminal Calculator
* A scientific calculator with a terminal-like UI and specific command for each operation
* Written in Java
* [Check repository](https://github.com/KMORaza/Terminal_Calculator_App)
### Moment of Inertia Calculator App
* Calculates moment of inertia of several bodies along different axes of rotation.
* [Java GUI App](https://github.com/KMORaza/Moment_of_Inertia-Calculator-GUI-App)
* [Java Console App](https://github.com/KMORaza/Moment_of_Inertia--Calculator--Java)
* [C++ Console App](https://github.com/KMORaza/Moment_of_Inertia--Calculator--CPP)
### Optimizing Aircraft Wing Material Distribution using Ant Colony Optimization (ACO)
* Optimize the thickness distribution of an aircraft wing to minimize its weight while ensuring structural integrity under specified load conditions. The wing is made of Aluminum 7075-T6 and modeled as a mesh of quadrilateral elements.
* Use ant colony optimization (ACO) to determine the optimal thickness for each element, subject to constraints on stress and buckling, evaluated via finite element analysis (FEA). The wing experiences steady, gust, and maneuver loads.
* Check [repository](https://github.com/KMORaza/ACO-based_Optimized_Aircraft_Wing_Material_Distribution) and [webpage](https://aco-optimized-aircraft-wing-design.netlify.app/).
### Optimizing Aircraft Wing Material Distribution using Ant Colony Optimization (ACO) with different approach
* The solution is written fully in Python and it aimes to optimize the material distribution of a simplified aircraft wing cross-section to minimize its weight while satisfying structural constraints. The wing is modeled as a thin-walled rectangular section subjected to an aerodynamic lift load.
* It is essential to select the thickness and fiber orientation of composite material elements (skin and spars) to ensure the structure can withstand stress, buckling, and displacement constraints, and maintain a minimum natural frequency.
* Check [repository](https://github.com/KMORaza/ACO-based_Optimized_Aircraft_Wing_Material_Distribution--Python_approach) and [webpage](https://optimized-aircraft-wing-design-py-aco.netlify.app/).
### Optimal Bridge design uisng ACO
* Optimizing structural design of bridge using ant colony optimization
* Check [repository](https://github.com/KMORaza/Optimal_Bridge_Design_using_ACO).
### Optimal Damper Placement using Bayesian Optimization (first approach)
* Overview
  * Parameters of an automotive suspension system are optimized to minimize an objective function that balances:
    * Comfort (Reducing acceleration felt by passengers)
    * Vibration (Minimizing chassis displacement)
    * Handling (Reducing pitch, roll, and tire force variations)
    * Constraints (Ensuring suspension stroke stays within limits)
  * Damper placement is indirectly optimized through parameters like motion ratio, inclination angle, and damping coefficients which affect how damping forces are transmitted to the suspension system.
* Functions
  * Simulates the half-car model and evaluates the objective function for a given set of suspension parameters.
  * Compression and rebound damping coefficients (Ns/m) controls damper force.
  * Motion ratio scales the damper's effect based on its mechanical advantage in the suspension linkage.
  * Inclination angle affects the effective damping force via cosine projection while knee point, blowoff, hysteresis, temp coeff. define nonlinear damping behavior.
  * Modelling the vehicle's response to road inputs using a 10-state half-car model (sprung/unsprung masses, pitch, roll, etc.).
  * Damping forces are computed incorporating nonlinear effects like blow-off thresholds and temperature-dependent damping.
  * Outputs (acceleration, displacement, pitch, roll, tire forces, max stroke) are used to compute the objective function
  * Damper placement affects comfort (via acceleration) and handling (via pitch/roll).
  * Bayesian Optimization is utilized and it optimizes the suspension parameters by modeling the objective function with a Gaussian Process (GP) and maximizing the Expected Improvement (EI) acquisition function.
  * Initialization uses Latin Hypercube Sampling to generate initial parameter sets and optimization loop fits the GP to observed data, predicts mean/variance for new points, and selects the next parameters by maximizing EI over 1000 random samples.
  * All 16 parameters are optimized within bounds.
  * The GP indirectly learns how motion ratio and inclination angle impact the objective, optimizing their values to improve damping effectiveness.
  * A random road profile is generated to simulate realistic road inputs.
  * An ISO 8608-like roughness model with smoothed noise, providing displacement and velocity inputs to the half-car model is used.
  * The road profile drives the suspension dynamics, testing the damper’s ability to absorb disturbances.
  * Power Spectral Density (PSD) of chassis displacement to evaluate vibration, which is influenced by damper settings is computed.
* Optimization of damper placement
  * Motion ratio (0.5–1.5) determines how damper motion translates to suspension motion. A higher ratio increases damping force but may reduce stroke range.
  * Inclination angle (0–30°) affects the effective damping force. A smaller angle (closer to vertical) maximizes force transmission, while a larger angle may reduce wear or fit packaging constraints.
  * Damping coefficients control the damper’s force-velocity relationship, tuned to balance comfort and handling.
  * Non-linear damping parameters i.e blowoff, knee point, hysteresis, temp coefficient allow the damper to adapt to different velocities and conditions, indirectly influenced by placement.
  * Bayesian optimizer explores combinations of these parameters, using the GP to model the objective function’s response.
  * The EI acquisition function prioritizes parameter sets that are likely to improve the objective, efficiently navigating the trade-offs between comfort, vibration, handling, and constraints.
* Sample workflow
  * 10 initial parameter sets are sampled (e.g., $C_c$ = 2000, $C_r$ = 4000, motion ratio = 1.0, inclination = 15°).
  * The `VehicleDynamics::evaluateObjective` function simulates each set, computing the objective value (e.g., 5.2).
  * The GP is fitted to the initial (parameters, objective) pairs.
  * For each iteration (30 total):
    * 1000 random parameter sets are evaluated using the EI function.
    * The set with the highest EI (e.g., $C_c$ = 2500, $C_r$ = 4500, motion ratio = 1.2, inclination = 10°) is simulated.
    * The new result updates the GP, refining predictions.
  * After 30 iterations, the best parameters are returned (e.g., $C_c$ = 3000, $C_r$ = 5000, motion ratio = 1.1, inclination = 8°, objective = 4.8).
  * These values optimize damper placement (via motion ratio and inclination) and damping behavior for the given road profile and vehicle model. 
* Check [webpage](https://bo-optimal-damper-placement-1.netlify.app/) about the solution and the [repository](https://github.com/KMORaza/BO-based-Damper_Placement_Optimization).
### Optimal Damper Placement using Bayesian Optimization (second approach)
A multi-objective solution that utilizes Bayesian Optimization (BO) to optimize damper placement and parameters in an automotive suspension system. 

The solution is to minimize three objectives—comfort (ISO 2631), vibration (frequency-weighted PSD), and handling (tire load variation)—across different road profiles (urban, highway, off-road) and damping profiles (linear, digressive, progressive).

* Defines fixed vehicle parameters (e.g., sprung mass = 1500 kg, unsprung mass = 50 kg per wheel, tire stiffness = 200000 N/m).
* Implements a Gaussian Process (GP) regression model & uses a Radial Basis Function (RBF) kernel
* Supports incremental updates to the kernel matrix using the Sherman-Morrison formula for efficiency.
* Provision for mean predictions and for uncertainty estimates, crucial for Bayesian optimization’s exploration-exploitation trade-off.
* Uses three surrogate ensemble instances (one per objective: comfort, vibration, handling) to model the objective function.
* Initializes with 30 random points, then iteratively selects new points using Simulated Annealing to maximize an active learning score combining Expected Hypervolume Improvement (EHVI), variance, and diversity.
* Maintains Pareto front to store non-dominated solutions, with adaptive weights based on crowding entropy to balance objectives.
* Uses EHVI to balance comfort, vibration, and handling, ensuring a diverse Pareto front.
* The ensemble of GP, RF, and NN provides robust predictions and uncertainty estimates, critical for Bayesian optimization.
* Incremental updates (e.g., Sherman-Morrison in GP) improve efficiency as new points are added.
* Parallel evaluation of objectives reduces runtime for expensive simulations.
* Simulated Annealing optimizes the acquisition function, balancing exploration and exploitation.
* Handles invalid objectives (NaN, infinite, or excessively large) by retrying with perturbed parameters or assigning high penalties.

Check [webpage](https://bo-optimal-damper-placement-2.netlify.app/) about the solution and the [repository](https://github.com/KMORaza/BO-based-Damper_Placement_Optimization--approach2).

### Optimizing engine crankshaft fatigue life using XGBoost
* Check [repository](https://github.com/KMORaza/Optimal_Engine_Crankshaft_Fatigue_Life_using_XGBoost) and [notebook](https://github.com/KMORaza/Optimal_Engine_Crankshaft_Fatigue_Life_using_XGBoost/blob/main/Optimizing_Engine_Crankshaft_Fatigue_Life.ipynb).
### Simulation of Lattice-Gas Model
* JavaFX application which simulates lattice gas model
* Check [repository](https://github.com/KMORaza/Lattice_Gas_Model_Simulation).
### Lattice-Boltzmann Model
* Written in C and C++
* Check [repository](https://github.com/KMORaza/Lattice_Boltzmann_Model).
### Latticce-Boltzman Model Simulation App
* * The application simulates fluid dynamics using the Lattice-Boltzmann model and helps to visualize fluid flow with different lattice types, collision operators, and boundary conditions.
* Supported lattice types :-
  * D2Q9: 2D lattice with 9 velocity directions, 100x100 grid.
  * D3Q15: 3D lattice with 15 velocity directions, 50x50x50 grid.
  * D3Q19: 3D lattice with 19 velocity directions, 50x50x50 grid.
  * D3Q27: 3D lattice with 27 velocity directions, 50x50x50 grid.
* Each lattice defines velocity vectors (C) and weights (W) for particle distributions. The simulation computes fluid density (rho) and velocities (ux, uy, uz) at each grid point, stored in arrays.
* Functions performed by simulation loop :-
  * Compute macroscopic quantities: Calculates density and velocities from the distribution functions (f).
  * Collide: Updates particle distributions based on the chosen collision operator.
  * Stream: Moves distributions along velocity directions.
  * Apply boundary conditions: Enforces rules at the grid boundaries.
  * Visualization: Updates the canvas with the current velocity field.
* Collision operators :-
  * SRT (Single Relaxation Time): Uses a single relaxation parameter (omega = 1/0.6) for all moments, applied to all lattices.
  * MRT (Multiple Relaxation Time): Uses multiple relaxation rates for different moments, implemented for D2Q9 only.
  * TRT (Two Relaxation Time): Uses symmetric and antisymmetric relaxation times, for D2Q9 only.
  * Entropic: Adjusts relaxation to maximize entropy, for D2Q9 only. For 3D lattices, non-SRT operators default to SRT.
* Boundary conditions :-
  * Bounce-back: Reflects particles at walls, simulating no-slip conditions.
  * Velocity: Sets a fixed velocity (0.1 in x-direction) at the left boundary (x=0), with bounce-back elsewhere.
  * Pressure: Fixes density (1.0) at the right boundary (x=NX-1), with bounce-back elsewhere.
  * Periodic: Wraps particles around opposite boundaries.
  * Inlet/Outlet: Combines velocity at the left and pressure at the right, with bounce-back on top/bottom.
  * Open: Copies distributions from neighboring cells, allowing free flow through boundaries.
* The simulation initializes with a uniform density (1.0) and zero velocity, except for specific boundary conditions (e.g., 0.1 x-velocity at x=0 for Velocity/Inlet/Outlet). An obstacle is placed to demonstrate flow interaction, visible in the visualization.
* Check [repository](https://github.com/KMORaza/Lattice_Boltzmann_Model_Simulation).
### Simulation of Q-State Potts Model
* Desktop app to simulate Q-State Potts Model.
* Metropolis algorithm: Single-site updates with energy-based acceptance.
* Heat Bath algorithm: Probabilistic state selection based on neighbor energies.
* Swendsen-Wang algorithm: Cluster-based updates using Union-Find for efficient cluster formation.
* Built for supporting 2D lattices, multiple geometries, and boundary conditions, with three algorithms.
* Used GTK4 for the GUI, with a drawing area for visualization and controls for parameter input.
* Written fully in C language.
### Model of Stommel's Two-Box Thermohaline Circulation
* Model of Stommel's Two-Box Thermohaline Circulation (STBC), written in JavaFX.
* * Simulates thermohaline circulation by modeling the interaction between temperature difference (T) and salinity difference (S) between two ocean boxes such as a polar and an equatorial box.
* The circulation strength, represented by the flow rate q, is driven by density differences caused by thermal and saline expansion. The model incorporates stochastic forcing (noise) and uses numerical integration to evolve the system over time.
* The model uses the Runge-Kutta 4th-order (RK4) method for numerical integration.
* Simulation logic:-
  * Defines the core mathematical model and simulation logic.
  * Implements numerical integration and steady-state computation.
  * Plots time series of T (red), S (blue), and q (green) during simulation.
  * Plots steady-state q vs. μ (yellow) to analyze system behavior across a range of μ values (0.01 to 0.5).
  * Updates the simulation and redraws the plot in real-time when running.
  * Allows exploration of how steady-state flow q changes with the freshwater flux parameter μ, revealing potential bifurcations (e.g., transitions between circulation regimes).
  * The model includes Gaussian noise to simulate environmental variability.
* Check [repository](https://github.com/KMORaza/STBTC_Model).
### SWE-based Coastal Ocean Dynamics Software
* The application models coastal ocean dynamics such as tsunamis, tides, and storm surges utilizing Shallow Water Equations (SWE) and is written in JavaFX.
* Utilizes continuity equation and momentum equations and discretizes these equations using a semi-explicit finite difference method and includes like nonlinear advection, wetting and drying, and variable wind stress.
* Triggers a Gaussian-shaped wave pulse to model tsunami propagation for visualizing tsunami.
* Simulates tides with single or combined tidal constituents (M2 and S2) for tidal forcing.
* Models wind-driven surges with uniform or spatially varying (cyclone) wind stress.
* Models coastal inundation by setting dry cells where water height is below the bathymetry.
* Toggles Coriolis force and bottom friction for realistic dynamics are for Coriolis effect and friction.
* Displays water height, velocity magnitude, or bathymetry using customizable colormaps (Blue-Red, Viridis, Grayscale).
* Shows tracer particles to track fluid motion.
* Overlays velocity vectors to visualize flow direction.
* Draws contour lines for water height at user-specified levels.
* Includes a line chart to track water height at the grid center over time.
* Saves water height, velocity magnitude, and bathymetry data to a CSV file.
* Uses a semi-explicit finite difference scheme for solving the SWE.
* Implements upwind advection for nonlinear terms when enabled.
* Applies reflective boundary conditions to simulate closed boundaries.
* Supports variable grid sizes (50 to 150) and adjustable time steps (0.01 to 0.2 seconds).
* Updates the SWE fields using finite differences, handles tidal forcing, wind stress, and wetting/drying.
* Advances tracer particle positions based on velocity fields.
* Renders the simulation state on the canvas, including colormaps, vectors, contours, and particles.
* Check [repository](https://github.com/KMORaza/SWE-Coastal_Ocean_Dynamics_Software).
### Model of Quasi-Geostrophy
* * Desktop app which creates a Quasi-Geotrophy (QG) mode and is written in C-language.
* Stores model configuration parameters like number of layers, grid size, time step (dt), beta parameter, Coriolis parameter (f0), gravity (g), layer thickness (H), geometry, solver type, boundary conditions, wind forcing, and topography scale.
* Holds simulation data, including arrays for streamfunction (psi), potential vorticity (q), previous PV (q_prev), velocities (u, v), topography, and FFTW arrays for spectral computations.
* Allocates memory for model arrays based on grid size (default 64x64) and number of layers (2–4).
* Initializes the streamfunction with a zonal jet (sinusoidal pattern) plus perturbations to simulate realistic flow.
* Sets up topography as a Gaussian ridge and configures FFTW plans for fast Fourier transforms used in PV inversion.
* Calculates velocities (u, v) from the streamfunction using finite differences.
* Transforms Potential Vorticity or PV (q) to spectral space using FFT and inverts the PV to obtain the streamfunction (ψ) using a Helmholtz-like equation, accounting for stretching due to stratification.
* Supports 2-layer or single-layer inversion, adjusting for the stretching term (f0^2/(g*H)).
* Applies inverse FFT to return the streamfunction to physical space.
* Calculates velocities (u, v) from the streamfunction using finite differences.
* Computes PV tendencies (dq_dt) including:
  * Advection: Nonlinear term -u * dq/dx - v * dq/dy.
  * Beta effect: Accounts for Coriolis variation (-β * v).
  * Wind forcing: Double-gyre wind stress applied to the top layer.
  * Friction: Linear damping in the bottom layer.
  * Topography: Interaction with bottom topography in the bottom layer.
  * Hyperdiffusion: High-order diffusion to damp small-scale noise.
  * Sponge layer: For open boundaries, damps PV near domain edges.
* Utilizes Runge-Kutta 4, Leapfrog, and Semi-Implicit time stepping solvers.
* Computes the average kinetic energy per grid point based on velocities and estimates the speed of Rossby waves using the beta parameter and a typical wavenumber.
* The canvas displays the selected field using a color map, with values normalized to [-1, 1] for visualization and updates energy and Rossby speed in real-time.
* Study ocean gyres, Rossby waves, and topographic effects; Compare numerical solvers for stability and accuracy; Explore the impact of boundary conditions or geometry on flow patterns.
* Check [repository](https://github.com/KMORaza/Model_of_Quasi-Geostrophy).  
### Inverter Drive Simulation Software
* This software simulates electrical inverter drive and is written in JavaFX. Earlier (21 April 2025), I wrote a similar desktop app for simulating electrical inverter drive but I wrote that one in C programming language and with a different implementation.
* Check [repository](https://github.com/KMORaza/Inverter-Drive_Simulation_Software).
### EV Powertrain Simulation App
* Desktop-app that simulates electric vehicle powertrain dynamics including battery, motor, and vehicle performance.
* Check [repository](https://github.com/KMORaza/EV_Powertrain_Simulation_App).
### Optimal aircraft fuselage design using topology optimization
* Geometry :—
  * Generates a cylindrical mesh with nodes on concentric rings and quadrilateral (quad) elements.
  * Mesh is structured, with nodes defined by radius, angular position, and axial position.
  * Elements are quads connecting nodes in a structured grid, representing fuselage skin panels.
  * Panel area is approximated as total surface area divided by the number of elements.
* Finite Element Method :—
  * Implements a 3D FEM solver for linear static analysis with 3 DOFs per node (x, y, z displacements).
  * Supports mechanical loads (point forces), pressure loads (normal to surface), and thermal loads (uniform thermal expansion).
  * Uses a SIMP (Solid Isotropic Material with Penalization) model with a penalization factor p = 3.
  * Computes a simplified constitutive matrix for plane stress, with adjustments for composites.
  * Assembles a sparse global stiffness matrix using Eigen's triplet-based approach.
  * Applies Dirichlet boundary conditions (fixed ends of the cylinder).
  * Solves the linear system using Eigen's `SimplicialLDLT` solver.
  * Computes outputs like compliance, maximum stress (von Mises based on analytical hoop and longitudinal stresses), buckling factor (simplified panel buckling), fatigue life (S-N curve-based), and maximum deflection.
* Topology Optimization (TO) :—
  * Uses a density-based topology optimization approach (SIMP) with element-wise densities variables.
  * Optimizes for minimum compliance subject to a volume fraction constraint.
  * Applies stress and buckling constraints via penalties in the sensitivity analysis.
  * Updates densities using a bisection method to enforce the volume constraint.
  * Includes a convergence check based on density changes.
  * Adjusts densities aggressively when constraints are violated (e.g., stress or buckling limits).
* Uses Aluminum 2024-T3 as the material.
* Sets up a fuselage with realistic parameters (2 m radius, 10 m length, 4 mm skin thickness, 20 frames, 40 stringers).
* Configures the FEM solver and optimizer with constraints (volume fraction = 0.7, stress ≤ yield strength, buckling factor ≥ 0.6, min thickness = 4 mm).
* Written in C++.
### EV Powertrain Simulation App (enhanced)
* First enhancement
  * Users can adjust battery voltage (100–1000V), capacity (10–200kWh), motor power (50–500kW), vehicle mass (1000–3000kg), drag coefficient (0.1–0.5), regen efficiency (0–100%), drive mode, and acceleration (-1.5 to 1.5 m/s²).
  * Shows real-time values for speed, SoC, distance, energy consumed, torque, RPM, battery temperature, and efficiency.
  * Displays four waveforms with a grid overlay, color-coded for voltage (red), current (green), speed (blue), and temperature (yellow).
  * Calculates vehicle speed using Newton’s second law, accounting for acceleration, drag, and rolling resistance.
  * Drag force: `0.5 * dragCoefficient * 2.5 * 1.225 * speed^2` (assumes frontal area of 2.5m², air density 1.225kg/m³).
  * Rolling resistance: `0.01 * mass * 9.81`.
  * RPM is approximated as `speed * 50` (simplistic, assumes fixed gear ratio).
  * Torque is calculated as `power * powerFactor / (RPM * efficiency)`, with efficiency decreasing at high RPM.
  * Power consumption: `motorPower * powerFactor * (0.5 + 0.5 * |accel|) / (motorEfficiency * tempEfficiency)`.
  * SoC: `100 - (energyConsumed / batteryCapacity * 100)`.
  * Regenerative braking recovers energy when decelerating.
  * Battery temperature changes based on heat input (from power use) and cooling, using a thermal mass of 1000 J/°C.
  * Temperature is capped between 10°C and 70°C.
  * Stores 200 points for each parameter (voltage, current, speed, temperature).
  * Voltage and current include sinusoidal noise for realism.
  * Incorporates drag, rolling resistance, motor efficiency, regenerative braking, and thermal effects.
  * Drive modes add variety, simulating different driving styles.
* Second enhancement
  * Users can input values for battery voltage, capacity, motor power, vehicle mass, etc., within defined ranges (e.g., voltage: 100–1000V).
  * Drive mode selection (Eco, Normal, Sport) adjusts max acceleration and power factor.
  * Acceleration is controlled via a `Spinner` (-1.5 to 1.5 m/s²).
  * Regenerative braking can be enabled/disabled, with efficiency adjustable via a `Slider`.
  * Waveform visibility (voltage, current, speed, temperature) is toggled via `CheckBoxes`.
  * Time step is capped at 0.1s to prevent large jumps.
  * Calculates total force (force = mass * acceleration - drag - rolling resistance) & updates speed.
  * Computes RPM based on speed and gear ratio.
  * Calculates torque (torque = power * power factor / (RPM * efficiency).
  * Motor efficiency decreases with high RPM.
  * Power consumption depends on acceleration, motor efficiency, and temperature.
  * Energy consumed updates SoC & regenerative braking recovers energy when decelerating, modulated by efficiency and SoC.
  * Battery temperature changes based on heat input (from power use) and cooling.
  * Temperature is capped between 10°C and 70°C.
  * Models key EV components (battery, motor, vehicle) with realistic physics (drag, rolling resistance, regen braking).
  * Includes thermal effects and efficiency variations based on operating conditions.
* Check [repository](https://github.com/KMORaza/EV_Powertrain_Simulation_App--enhanced).
### Grinding Spindle Design Simulation Software
* Simulates spindle performance across scenarios (High-Speed, High-Torque, Balanced) and time-based simulations.
* Generates dynamic load profiles with sinusoidal variation and random spikes to simulate real-world conditions.
* Uses a k-Nearest Neighbors (k-NN) algorithm with historical data to predict maintenance needs.
* Provides comprehensive reports with scenario summaries and recommendations (e.g., switch to liquid cooling if temperature is high).
* Generates a maintenance schedule based on bearing type, lubrication type, and operating hours.
* Includes tasks like bearing inspection, lubrication maintenance, vibration monitoring, alignment checks, and general maintenance.
* Shows performance metrics (vibration, temperature, power, load, bearing life, spindle life, wheel wear) as color-coded bars (green for acceptable, red for exceeding thresholds).
* Covers a wide range of spindle performance aspects (power, thermal, vibration, fatigue, wear) with realistic calculations.
* The k-NN-based maintenance prediction adds predictive maintenance capabilities, enhancing practical utility.
* Check [repository](https://github.com/KMORaza/Grinding_Spindle_Design_Simulation_Software).
### MOGA-based Optimal Grinding Spindle Design
* The system simulates spindle performance under various conditions, evaluates metrics like vibration, temperature, and bearing life, and uses a k-Nearest Neighbors (k-NN) algorithm for maintenance prediction utilizes Multi-Objective Genetic Algorithm (MOGA) to optimize spindle parameters to minimize vibration, maximize bearing life, and minimize temperature rise.
* Covers multiple aspects of spindle performance (power, vibration, temperature, wear, fatigue).
* Supports different scenarios and time-based analysis, making it versatile for various use cases.
* Encapsulates spindle configuration with setters and getters, ensuring clean data management.
* Checks parameter validity, returning error messages for out-of-range values.
* Runs simulations across three scenarios (High-Speed, High-Torque, Balanced) with different speed and load factors. Outputs detailed metrics like power, vibration, and bearing life.
* Simulates performance over a user-specified duration, tracking vibration, temperature, and load at 0.1-second intervals.
* Uses kNN on historical data to predict if maintenance is needed based on vibration, temperature, and other metrics.
* Uses Multi-Objective Genetic Algorithm (MOGA) to find Pareto-optimal spindle configurations, balancing vibration, bearing life, and temperature.
* Performance calculations :—

  |                         |                                     |
  |-------------------------|-------------------------------------|
  | Power Calculation        | Estimates required power based on wheel diameter and speed|
  | Vibration | Models vibration based on bearing type, speed, alignment, and tool interface|
  | Temperature Rise | Accounts for cooling type, speed, preload, and load|
  | Bearing Life (L10) | Calculates bearing life using dynamic load profiles and lubrication adjustments|
  | Spindle Fatigue Life | Estimates remaining life based on load-induced stress and S-N curve parameters|
  | Wheel Wear | Models wear based on load, peripheral speed, and duration, impacting vibration|
* Optimization using Multi-Objective Genetic Algorithm (MOGA) :—
  * Minimize vibration, maximize bearing life (negated for minimization), and minimize temperature rise.
  * Evolves a population of spindle configurations over generations.
  * Ranks solutions based on Pareto dominance, using crowding distance for diversity.
  * Uses BLX-α crossover for continuous parameters and uniform crossover for categorical ones, with polynomial mutation for continuous parameters.
  * Returns a Pareto front of optimal configurations with detailed parameters and objectives.
* Check [repository](https://github.com/KMORaza/MOGA-Optimal_Grinding_Spindle_Design).
### Software for Hybrid Bearing System Design Simulation
* This desktop app provides a comprehensive simulation environment for analyzing hybrid bearing systems, combining magnetic, ceramic, and hybrid bearing technologies.
* Physics model :—
  * Implements a Runge-Kutta 4th order integration for accurate dynamics simulation.
  * Includes thermal modeling with heat generation/dissipation calculations.
  * Models magnetic field effects for magnetic/hybrid bearings.
  * Calculates stress distribution based on material properties.
  * Implements contact mechanics with friction modeling.
  * Rotor motion: Simulates 1D vertical displacement with stiffness (spring-like restoring force), damping (velocity-dependent resistance), gyroscopic effects (speed-dependent coupling).
  * Contact Mechanics (Hertzian contact)
    * Stress ∝ Load / (Material Stiffness × Contact Area)
    * Friction ∝ Load × Speed (empirical model)
  * Thermal system
    * Frictional losses
    * Eddy currents (in magnetic bearings)
    * Convection (surface cooling)
    * Conduction (through materials)
* Control system :—
  * PID controller with anti-windup protection.
  * Kalman filter for state estimation.
  * Proper clamping of all values to prevent numerical instability.
  * Real-time tuning through interactive sliders.
### Inverter Drive Simulation Software with MOO
* This desktop software simulates an electrical inverter drive and is written in JavaFX. This software is an enhanced version of the software which I wrote earlier. I enhanced the earlier version by incorporating multi-objective optimization (MOO) technique. I used Non-dominated Sorting Genetic Algorithm II (NSGA-II).
* The NSGA-II-based multi-objective optimization successfully balances power loss, temperature, and fault resilience.
* Configuration - Defines constants for simulation parameters, such as time step, thermal properties, convection coefficients, and fault simulation settings. These constants are used across the system to ensure consistency.
* Data logging - Logs simulation data (time, voltages, currents, speed, torque, control mode, and faults) to a CSV file.
* Fault simulation - Simulates faults like overcurrent, undervoltage, phase loss, overheat, and IGBT failure. It modifies phase voltages based on fault conditions and supports auto-reset after a 2-second delay.
* Induction motor model - Models an induction motor with parameters like rated voltage, power, resistance, and thermal characteristics. It updates motor state (speed, torque, temperature) based on input voltages, currents, and load type, incorporating thermal dynamics and cooling effects.
* Power stage - Simulates the inverter's power stage, generating phase voltages from PWM signals using SPWM or SVPWM techniques. It accounts for DC-link voltage, PWM frequency, dead time, modulation index, harmonic injection, overmodulation, and thermal behavior.
* Sensor model - Models current sensors with Gaussian noise and supports fault simulation (complete or partial failure) to mimic real-world sensor inaccuracies.
* V/f control system
  * V/f (Voltage/Frequency): Maintains a constant voltage-to-frequency ratio with PI control for speed regulation.
  * FOC (Field-Oriented Control): Uses PI controllers for torque and flux, transforming d-q voltages to three-phase signals.
  * DTC (Direct Torque Control): Applies hysteresis-based control using a switching table to select voltage vectors.
* Waveform visualization - Visualizes phase voltages, currents, and motor speed on a JavaFX canvas, with dynamic scaling and color-coded waveforms for real-time monitoring.
* Optimization - Implements Non-dominated Sorting Genetic Algorithm II (NSGA-II), a multi-objective genetic algorithm to optimize inverter and motor parameters.
* Combines switching losses (proportional to PWM frequency and DC-link voltage) and conduction losses (I²R losses in the motor).
* Tracks the highest temperature of the motor or inverter to ensure thermal stability.
* Measures the deviation of motor speed from the reference (100 rad/s) under an overcurrent fault, reflecting system robustness.
* NSGA-II optimization logic
  * Population: 50 individuals, each representing a set of the four parameters.
  * Crossover: Blended crossover with a 90% probability, combining parent parameters.
  * Mutation: Gaussian mutation with a 10% probability, perturbing parameters within bounds.
  * Selection: Tournament selection based on rank and crowding distance.
  * Non-Dominated Sorting: Assigns ranks to individuals based on dominance (an individual dominates another if it is better in at least one objective and not worse in any).
  * Crowding Distance: Ensures diversity by favoring individuals in less crowded regions of the Pareto front.
  * Initialization: Randomly generates a population within parameter bounds.
  * Evaluation: Simulates each individual for 1 second (10,000 steps at 0.0001s time step) with an overcurrent fault. Computes average power loss, maximum temperature, and average fault impact.
  * Evolution: Generates offspring via crossover and mutation, combines with the parent population, and selects the top 50 individuals based on rank and crowding distance.
  * Outcome: Returns the Pareto front (rank 1 individuals), sorted by power loss.
* Check [repository](https://github.com/KMORaza/MOO_Inverter_Drive_Simulation_Software).
### Cathode Ray Oscilloscope Simulation Software
* Desktop software for simulation of Cathode Ray Oscilloscope.
* Check [repository](https://github.com/KMORaza/Cathode_Ray_Oscilloscope_Simulator).
### Capacitance Meter Simulation Software
* Desktop software to simulate a capacitance meter.
* Check [repository](https://github.com/KMORaza/Capacitance_Meter_Simulation_Software).
### Arbitrary Waveform Generation (AWG) Software
* This software simulates Arbitrary Waveform Generator (AWG) and is written in JavaFX programming language.
* Generates the base waveform based on the selected type and parameters.
* Applies modulation to the base waveform to simulate communication signals.
* Adds noise to the waveform to simulate real-world signal imperfections.
* Coordinates user inputs, waveform generation, modulation, noise application, and visualization.
* Centralizes all simulation parameters in a single model for consistent access.
* Check [repository](https://github.com/KMORaza/AWG-Software).
### Spectrum Analyzer Software
* Generates simulated signal data, applies window functions, demodulation, and analysis modes.
* Applies the selected window function to the amplitude data to reduce spectral leakage.
* Supports Hanning, Blackman-Harris, Kaiser, Flat-Top, and Gaussian windows, each with specific coefficients or parameters (e.g., Kaiser uses a Bessel function with β=8.6).
* Renders the signal spectrum or persistence display on a canvas.
* Displays the demodulated signal waveform.
* Applies demodulation to the signal based on the selected type.
* Identifies the signal type based on spectral characteristics.
* Stores and provides access to spectral data.
* Check [repository](https://github.com/KMORaza/Spectrum_Analyzer_Software).
### Logic Analyzer Software
* Simulates a logic analyzer to capture, display, and analyze digital signals across multiple channels.
* Generates random square wave signals with a 5% chance of toggling per sample.
* Supports multiple channels (default: 8) and configurable sample rates (default: 1000 Hz).
* Controls: Start, Stop, Reset buttons; sample rate input; trigger settings; zoom/scroll; cursor placement; FFT channel selection.
* Displays: Waveform plot, FFT spectrum, eye diagram, decoded UART data, signal metrics, and glitch reports.
* Interactivity: Zoom, scroll, and cursors for time measurements.
* Supports rising edge, falling edge, and pattern-based triggers.
* Aligns captured data based on trigger conditions.
* Simulates UART decoding (9600 baud, 8N1) by identifying start/stop bits and extracting bytes.
* FFT: Computes frequency components using a recursive FFT algorithm.
* Metrics: Calculates frequency, duty cycle, rise/fall times.
* Glitch Detection: Identifies single-sample anomalies.
* Overlays signal periods to visualize signal integrity, assuming a 1kHz signal.
* Check [repository](https://github.com/KMORaza/Logic_Analyzer_Software).
### Pattern Generator App
* Desktop app to generate and visualize digital signal.
* Check [repository](https://github.com/KMORaza/Pattern_Generator).
### Spectrum Analyzer Software (enhanced)
This software is an enhanced version of Spectrum Analyzer, a software I wrote previously. In this version, I incorporated more controls and improved UI and layout of the software.
- `MainClass` starts the software, loads `spectrum_analyzer.fxml`, applies `style.css`, sets stage title to "Spectrum Analyzer", and displays 1200x800 scene
- `SignalProcessor` generates simulated spectrum data with 16384 bins, default frequency range 20 Hz to 1000 Hz
- `SignalProcessor` initializes `SpectrumData`, `SignalClassifier`, `Demodulator`, and uses `ExecutorService` for asynchronous data generation
- `SignalProcessor` sets frequency range via `setFrequencyRange`, updates `minFreq`, `maxFreq`, and regenerates data
- `SignalProcessor` sets analysis mode (FFT or Swept-Tuned) via `setAnalysisMode` and regenerates data
- `SignalProcessor` sets window function (Hanning, Blackman-Harris, Kaiser, Flat-Top, Gaussian) via `setWindowFunction` and regenerates data
- `SignalProcessor` sets demodulation type (None, AM, FM, PM, QAM, PSK, OFDM) via `setDemodulationType` and regenerates data
- `SignalProcessor` sets sweep speed via `setSweepSpeed`, scales amplitudes in Swept-Tuned mode, and regenerates data
- `SignalProcessor` generates simulated data with noise floor (`-160 - 20 * log10(maxFreq/1000)`) and Gaussian peaks for Wi-Fi (150 Hz, +100 dB), Bluetooth (2440 MHz, +80 dB), LTE (1800 MHz, +90 dB), 5G NR (3600 MHz, +85 dB), Zigbee (2425 MHz, +75 dB)
- `SignalProcessor` applies window function to amplitudes, generates random phases (0 to 2π), and demodulates if enabled
- `SignalProcessor` generates window function array in parallel using `IntStream` for Hanning, Blackman-Harris, Kaiser, Flat-Top, or Gaussian
- `SignalProcessor` computes modified Bessel function (`besselI0`) for Kaiser window
- `SignalProcessor` classifies signal type via `SignalClassifier` and provides frequency-specific classification
- `SpectrumData` stores amplitudes, phases, `minFreq`, `maxFreq`, and size (16384)
- `SpectrumData` updates data via `update` method and provides getters for amplitudes, phases, frequency range, and size
- `Demodulator` demodulates amplitudes based on type: AM (`abs(amp) * cos(phase)), FM ((phase[i] - phase[i-1]) / 2π`), PM (`phase / 2π`), QAM (`sqrt(I^2 + Q^2)`), PSK (quantized phase to `π/4`), OFDM (`abs(amp) * cos(phase + random offset)`)
- `Demodulator` generates random phase offset (0 to π/8) for OFDM
- `SignalClassifier` identifies signal type based on peak frequency and amplitude: Bluetooth (2400–2480 MHz, >-100 dBm), Wi-Fi (100–200 Hz, >-80 dBm), LTE (700–2700 MHz, >-90 dBm), 5G NR (3500–3700 MHz, >-95 dBm), Zigbee (2400–2450 MHz, >-105 dBm), else Unknown
- `SignalClassifier` calculates confidence (90% if peak count < 5, else 70%) and returns signal type with percentage
- `SpectrumCanvas` renders spectrum plot with 1160x400 resolution, supports zoom (scroll), pan (drag), and marker addition (double-click)
- `SpectrumCanvas` sets dynamic range (default 160 dB), channel bandwidth (default 1000 Hz), channel count (default 1), log scale, display mode (Spectrum), grid visibility, and grid spacing
- `SpectrumCanvas` adds annotations at specified coordinates and clears them via `clearAnnotations`
- `SpectrumCanvas` resets zoom (`zoomFactor` = 1.0) and pan (`offsetX` = 0.0) via `resetZoomPan`
- `SpectrumCanvas` adds markers at specified frequency with amplitude and signal type, clears user-added markers
- `SpectrumCanvas` updates canvas by drawing spectrum or persistence plot, grid, channels, markers, and annotations
- `SpectrumCanvas` draws spectrum as yellow line plot, scaling x-axis (`width` / `amplitudes.length`) and y-axis (`height` / `dynamicRange`)
- `SpectrumCanvas` draws persistence plot as green heatmap, decaying buffer values (* 0.95) and adding amplitude contributions
- `SpectrumCanvas` draws grid with frequency and amplitude labels if `gridVisible`, using `gridSpacing` lines
- `SpectrumCanvas` draws red channel markers based on `channelBandwidth` and `channelCount` around center frequency
- `SpectrumCanvas` draws cyan markers with frequency and amplitude labels
- `SpectrumCanvas` draws white text annotations at specified coordinates
- `SpectrumCanvas` detects peaks (amplitude > neighbors and >-100 dBm) and adds them as `Marker` objects to `metricsData`
- `SpectrumCanvas` converts pixel x-coordinate to frequency based on zoom and offset
- `SpectrumCanvas` computes channel power as average power (dBm) within main channel bandwidth
- `SpectrumCanvas` computes ACPR as difference between main and adjacent channel power
- `DemodCanvas` renders demodulated signal as yellow waveform on 1160x150 canvas, scaling x-axis (`width` / `amplitudes.length`) and y-axis (`height` / 400)
- `DemodCanvas` draws dark gray center line
- `Marker` represents marker or peak with type, frequency, amplitude, and signal type
- `Annotation` represents text annotation with text and x, y coordinates
- `SpectrumAnalyzerController` initializes GUI, `SignalProcessor`, `SpectrumCanvas`, and `DemodCanvas`
- `SpectrumAnalyzerController` sets up UI listeners for frequency slider (20 Hz to 50 GHz), dynamic range slider (100–200 dB), sweep speed slider (0.1–10), display mode combo box (Spectrum), analysis mode combo box (FFT, Swept-Tuned), window combo box, demodulation combo box, channel bandwidth field, channel count field (1–5), log scale toggle, export button, reset button, zoom/pan reset button, marker buttons, grid toggle, grid spacing slider, and annotation button
- `SpectrumAnalyzerController` validates channel bandwidth (>0) and channel count (1–5) inputs
- `SpectrumAnalyzerController` updates channel power, ACPR, and signal type labels in real-time
- `SpectrumAnalyzerController` updates window info label with sidelobe and resolution details for selected window function
- `SpectrumAnalyzerController` exports channel power and ACPR to `power_report.csv`
- `SpectrumAnalyzerController` resets settings to defaults: frequency 1000 Hz, dynamic range 160 dB, sweep speed 1.0, FFT mode, Hanning window, no demodulation, channel bandwidth 1000 Hz, channel count 1, log scale off, grid on, grid spacing 10
- `SpectrumAnalyzerController` resets zoom and pan via `resetZoomPan`
- `SpectrumAnalyzerController` adds marker at center frequency
- `SpectrumAnalyzerController` clears all markers
- `SpectrumAnalyzerController` adds annotation at canvas center if text is provided
- `SpectrumAnalyzerController` displays alerts for success or error messages
- `SpectrumAnalyzerController` uses `AnimationTimer` to continuously update `SpectrumCanvas`, `DemodCanvas`, and metrics labels
- Check [repository](https://github.com/KMORaza/Spectrum_Analyzer_Software--enhanced).
### Brushless DC Motor Simulation Software
  * Computes phase currents based on applied voltages, back-EMF, phase resistance, and inductance (adjusted for magnetic saturation).
  * Supports fault conditions like phase loss (zero current in a phase) or short circuits (low resistance between phases).
  * Calculates back-EMF for each phase, using trapezoidal or sinusoidal waveforms depending on the motor type.
  * Transforms phase currents to d-q frame for Field-Oriented Control (FOC) using Park and Clarke transforms.
  * Models rotor motion using a second-order system (moment of inertia, friction, and torques).
  * Calculates electromagnetic torque (based on currents and torque constant), cogging torque (due to slot effects), ripple torque (harmonic effects), and friction torque.
  * Updates rotor angle and speed using a 4th-order Runge-Kutta method for numerical integration.
  * Provides speed in RPM and commutation sector for 6-step control.
  * Configurable motor type (trapezoidal or sinusoidal).
  * Fault injection for phase loss or short circuits.
  * Inductance variation due to magnetic saturation.
  * Realistic torque components (cogging, ripple) for accurate dynamics.
  * Simulates the power electronics driving the motor, converting DC link voltage to phase voltages.
  * Supports two switching modes: Ideal (no losses) and Realistic (includes switching and conduction losses, dead time, and slew effects).
  * Implements 6-step PWM (for trapezoidal control) or SVPWM (for sinusoidal FOC).
  * Converts desired voltages to duty cycles, applying constraints (e.g., maximum DC link voltage).
  * Calculates output voltages, accounting for MOSFET on-resistance and dead time distortion in realistic mode.
  * Tracks switching losses (based on MOSFET switching energies) and conduction losses.
  * Estimates inverter temperature based on power losses and supports thermal derating and shutdown when temperature exceeds thresholds.
  * Realistic switching effects (dead time, rise/fall times); Thermal monitoring for protection; Flexible PWM strategies (6-step or SVPWM).
  * Updates DC link voltage based on capacitor charge and inverter input current (sum of absolute phase currents).
  * Models voltage drop due to ESR and recharge from a nominal voltage source.
  * Ensures non-negative voltage.
  * Supports overvoltage fault injection (e.g., setting nominal voltage to 32V, above the 30V threshold).
  * Dynamic voltage response to load changes; Fault injection for overvoltage testing; Reset functionality to restore nominal conditions.
  * Trapezoidal Control (6-Step PWM)
    * Uses commutation sector (from rotor angle or fault-affected sensor) to energize two phases at a time.
    * Employs PID controllers for current regulation in active phases, with torque demand derived from speed error.
    * Applies voltages via the inverter in 6-step mode.
  * Sinusoidal Control (FOC)
    * PID Mode
      * Converts speed error to q-axis current reference using a speed PID controller.
      * Sets d-axis current reference to 0 for MTPA or adjusts for field weakening at high speeds.
      * Uses two PID controllers to regulate d- and q-axis currents, computing d-q voltages.
      * Applies inverse Park and Clarke transforms to convert d-q voltages to phase voltages.
    * MPC Mode
      * Delegates control to MPC controller model which computes optimal d- and q-axis voltages.
      * Transforms voltages to phase voltages for inverter application.
  * MTPA: Maximizes torque per ampere for surface-mount PMSMs.
  * Field Weakening: Reduces back-EMF at high speeds, respecting voltage and current limits.
  * Adaptive Control: Adjusts PID gains based on estimated resistance and inductance.
  * Integrates with fault manager to respect derating factors or stop operation during protection events.
  * Uses a discretized state-space model to predict motor behavior.
  * Defines cost function with weights for speed error, d- and q-axis current errors, and control effort.
  * Performs grid search, respecting voltage and current constraints.
  * Selects control inputs minimizing the cost over the prediction horizon (default N=5).
  * Accounts for load torque and back-EMF as disturbances.
  * Predictive control for improved performance; Constraint handling (voltage, current limits); Tunable parameters for flexibility.
  * Computes control output using proportional, integral, and derivative terms.
  * Includes integral anti-windup with configurable limits.
  * Supports dynamic gain updates and setpoint changes.
  * Resets integral and error terms when stopping the motor.
  * Anti-windup for stable control.
  * Flexible gain tuning.
  * Uses Recursive Least Squares (RLS) to estimate motor parameters (phase resistance and inductance).
  * Updates estimates based on phase voltages, currents, back-EMF, and current derivative.
  * Uses a forgetting factor (lambda = 0.99) to prioritize recent data.
  * Maintains a covariance matrix to adapt estimation gains.
  * Constrains estimated parameters to realistic bounds (0.1–10 Ω, 0.1–10 mH).
  * Skips estimation for low currents (|I| < 0.1 A) to avoid noise.
  * Fault Injection
    * Phase Loss: Sets a phase current to zero.
    * Short Circuit: Connects two phases with low resistance (0.01 Ω).
    * Sensor Failure: Simulates stuck or noisy rotor angle sensor.
    * Overvoltage: Increases DC link voltage (e.g., to 32V).
    * Overcurrent: Flags currents exceeding 10 A.
  * Monitors overcurrent (>10 A) and overvoltage (>30 V), triggering shutdowns.
  * Applies thermal derating when inverter temperature exceeds 80°C, shutting down at 120°C.
  * Provides derating factor (0–1) based on temperature.  
  * Estimates inverter temperature based on power losses.
  * Calculates temperature using a simplified model with thermal capacitance for inertia.
  * Includes natural cooling toward ambient temperature (25°C).
  * Ensures temperature remains above ambient.
  * Supports derating and shutdown logic.
  * Integrates all components, updating the system state at each time step.
  * Executes simulation in 100 µs sub-steps (100 sub-steps per 10 ms) for numerical stability.
  * Handles exceptions by stopping the motor and reporting errors.
  * Sets load torque (0–0.1 Nm) and speed reference (0–3000 RPM).
  * Centralized system integration.
  * Check [repository](https://github.com/KMORaza/Brushless_DC_Motor_Simulation_App).

---

## ACTIVITIES
* Weightlifting
* Football
* Cycling

--- 

_My best preferred snacks are a few brown bread toasts with some peanut butter and a sugar-free cup of coffee_

